# WEEK 1~10 学习总结

## 第一周：
通过一个简单的AI游戏练习，引入课程；通过红绿灯练习，介绍了异步的实现方式。
## 第二周：
实现了一个更丰富的寻路算法。从浅入深，逐步实现了广度优先搜索findPath；Sorted数据结构寻路findPathBySorted；二叉堆数据结构寻路findPathByBinaryHeap。
## 第三周：
简单学习了编译原理的知识。用了词法和语法分析，构建四则运算的AST。
## 第四周：
学习了字符串的匹配算法。讲了 trie 树，这是很有用，而且实现相对简单的算法；讲到了很经典的KMP算法，这个算法尽量要做到能徒手流畅的写出来。
## 第五周：
学习Proxy实现简单的toy reactive，以及 DOM 的精确操作。 用 document 来监听鼠标事件，防止鼠标滑出屏幕。

## 第六周：
从程序语言分类开始，介绍了语言的分类方法，帮助我们从不同角度来理解JavaScript。介绍了产生式，这是我之前不曾了解的方面；JS类型，JS对象。

### 乔姆斯基谱系：
是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的。它包括四个层次：

0- 型文法（无限制文法或短语结构文法）包括所有的文法。
1- 型文法（上下文相关文法）生成上下文相关语言。
2- 型文法（上下文无关文法）生成上下文无关语言。
3- 型文法（正规文法）生成正则语言。

### 巴科斯诺尔范式：
即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。

### 产生式： 
在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句

巴科斯诺尔范式：即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。
终结符： 最终在代码中出现的字符（ https://zh.wikipedia.org/wiki/ 終結符與非終結符)

### 图灵完备性：
在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完全的。这个词源于引入图灵机概念的数学家艾伦·图灵。虽然图灵机会受到储存能力的物理限制，图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”。

### 图灵机（Turing machine）：
又称确定型图灵机，是英国数学家艾伦·图灵于 1936 年提出的一种将人的计算行为抽象掉的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。

### 静态和动态语言： 
https://www.cnblogs.com/raind/p/8551791.html

### 强类型与弱类型：

强类型： 无隐式转换
弱类型： 有隐式转换

### 协变与逆变： 
https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html

### 找出 JavaScript 标准里面所有具有特殊行为的对象

Array：Array 的 length 属性根据最大的下标自动发生变化。 
Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。 
String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。 
Arguments：arguments 的非负整数型下标属性跟对应的变量联动。 
模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。 
类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。 
bind 后的 function：跟原来的函数相关联。

## 第七周：
介绍了JS的运算符和表达式。
运算符不同于数学意义上的运算，还有成员运算符等，介绍了运算符的优先级等。
表达式有了学科意义上的分类概念，之前没有规整这方面知识很零散。

## 第八周：
介绍了浏览器的工作原理。
http request → html → dom → css → layout → render

通过一系列例子，由浅入深的介绍了状态机。

介绍了request的格式：request line; header; body。介绍了部分header字段。

介绍了response的格式：status line; header; body。介绍了部分响应码及其含义。

实现请求的发送与接收，并对接收到的响应根据响应码等进行处理。

## 第九周：

### HTML解析
第一步
为了方便文件管理， 把parser单独拆到文件中
parseHTML接受HTML文本作为参数返回DON树

第二步
我们用FSM来实现HTML的分析（状态机）
在HTML的标准中，已经规定了HTML的状态
Toy-Browser只挑选其中一部分状态，完成一个最简版本

第三步
主要标签有： 开始标签、结束标签、自封闭标签

第四步
在状态机中，除了状态迁移，还要加入业务逻辑
我们在标签结束状态提交标签token

第五步
属性分为单引号 双引号 无引号三种写法，因此需要比较多的状态
处理方式和标签类似

第六步
从标签构建DOM树的基本技巧就是使用栈
遇到开始标签创建元素入栈，遇到结束标签出栈
自封闭节点可视为入栈后立即出栈
任何元素的父元素是他入栈前的栈顶
第七步
文本节点与自封闭标签类似处理类似
多个文本节点需要合并

### CSS computing

第一步
遇到style标签时，我们吧CSS规则保存起来
这里我们调用了CSS Parser 来分析CSS规则
这里我们必须要仔细的研究此库来分析CSS规则的样式

第二步
当我们创建一个元素后，立即计算CSS
理论上个当我们分析一个元素时， 所有css规则已经收集完毕
在真实的浏览器中，可能遇到写在body的style标签，需要从新计算css的情况，这里我们忽略

第三步
在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
我们从上一步骤的stack，可以获取本元素的所有父元素
因为我们首先获得的是 “当前元素” 所以我们获得和计算父元素的匹配顺讯是从内向外

第四步
选择器也要从当前元素向外排列
复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

第五步
根据选择器的类型和元素属性，计算是否与当前元素匹配
这里仅仅只实现了三种基本选择器，实际的浏览器中要处理复合选择器

第六步
一旦选择匹配，就应用选择器到元素上，形成computeStyle

第七步
CSS规则根据specificity和后来优先规则覆盖
speccificity是一个四元组，越左边权重越高
一个CSS规则的specificity根据简单的选择器相加而成

## 第十周

### DOM with CSS - layout
第一步  预处理
处理了flexDirection和wrap相关属性

第二步 分行
根据主轴尺寸，把元素分进行
若设置了no-wrap，则强行分配进第一行

第三步 计算主轴
找出所有flex元素
把主轴方向的剩余尺寸按比例分配给这些元素
若剩余空间为负数，所有flex元素为0，等比压缩剩余元素

第四步 计算交叉轴
计算交叉轴方向
根据每一行中最大元素尺寸计算行高
根据行高flex-align 和 item-align，确定元素具体位置

### DOM with position - render
第一步
绘制需要依赖一个图形环境
我们这里采用了npm包images
绘制在一个viewport上进行
与绘制相关的属性：background-color\border\background-image等

第二步
递归调用子元素的绘制方法完成DOM树的绘制
忽略一些不需要绘制的节点
实际浏览器中，文字绘制是难点，需要依赖字体库，我们这里忽略




## 学习总结
随着时间推进，感觉难度在逐渐增加。
跟着老师敲代码的过程中，涉及的知识点和需要考虑的逻辑很多，需要自己多读几遍以便彻底理解。
给代码分模块和加注释是我认为很利于自己对代码深入理解的好方法，也一直在践行。
在听课的过程中，也不断的补充知识图谱。

对于课上的延展知识点，需要自己多查阅。

经过十周的学习，了解了很多之前没有注意到的细节，也对前端知识结构也有了很好的组织。做到了对知识的梳理和系统化。

希望接下来能保持好习惯，发展新的好的实践，不断深入前端。